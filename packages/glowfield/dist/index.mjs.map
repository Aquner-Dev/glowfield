{"version":3,"sources":["../src/AuroraCanvas.tsx"],"sourcesContent":["\"use client\";\nimport { useEffect, useRef } from \"react\";\nimport * as THREE from \"three\";\n\nexport type GlowfieldProps = {\n  colors?: string[];\n  speed?: number;\n  intensity?: number;\n  waveCount?: number;\n  debugMode?: boolean;\n  className?: string;\n};\n\nexport function AuroraCanvas({\n  colors = [\"#0a1929\", \"#1e40af\", \"#60a5fa\"],\n  speed = 0.5,\n  intensity = 0.85,\n  waveCount = 8,\n  debugMode = false,\n  className\n}: GlowfieldProps) {\n  const wrapRef = useRef<HTMLDivElement | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n\n  useEffect(() => {\n    const el = wrapRef.current;\n    if (!el) return;\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n    rendererRef.current = renderer;\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    renderer.setSize(el.clientWidth, el.clientHeight);\n    el.appendChild(renderer.domElement);\n\n    const scene = new THREE.Scene();\n    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n    const uniforms: Record<string, THREE.IUniform> = {\n      u_time: { value: 0 },\n      u_res: { value: new THREE.Vector2(el.clientWidth, el.clientHeight) },\n      u_intensity: { value: intensity },\n      u_speed: { value: speed },\n      u_waveCount: { value: Math.max(1, Math.min(8, waveCount)) },\n      u_debugMode: { value: debugMode ? 1.0 : 0.0 },\n      u_c0: { value: new THREE.Color(colors[0]) },\n      u_c1: { value: new THREE.Color(colors[1]) },\n      u_c2: { value: new THREE.Color(colors[2]) }\n    };\n\n    const frag = `\n      precision highp float;\n      uniform float u_time; uniform vec2 u_res;\n      uniform float u_speed; uniform float u_intensity;\n      uniform float u_waveCount;\n      uniform float u_debugMode;\n      uniform vec3 u_c0; uniform vec3 u_c1; uniform vec3 u_c2;\n\n      // より滑らかなノイズ関数（パーリン風）\n      vec2 hash22(vec2 p) {\n        p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n        return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n      }\n\n      float noise(vec2 p) {\n        vec2 i = floor(p);\n        vec2 f = fract(p);\n        vec2 u = f * f * (3.0 - 2.0 * f);\n        return mix(\n          mix(dot(hash22(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\n              dot(hash22(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\n          mix(dot(hash22(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n              dot(hash22(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x), u.y);\n      }\n\n      // フラクタルノイズ（複数オクターブ）\n      float fbm(vec2 p) {\n        float value = 0.0;\n        float amplitude = 0.5;\n        float frequency = 1.0;\n        for(int i = 0; i < 5; i++) {\n          value += amplitude * noise(p * frequency);\n          frequency *= 2.0;\n          amplitude *= 0.5;\n        }\n        return value;\n      }\n\n      void main(){\n        vec2 uv = gl_FragCoord.xy / u_res;\n        vec2 p = (uv - 0.5) * vec2(u_res.x/u_res.y, 1.0);\n        float t = u_time * u_speed;\n\n        // 画面外の遠い複数の中心点\n        vec2 center1 = vec2(3.5, 2.0);  // 右上の遠く\n        vec2 center2 = vec2(-2.8, -3.2); // 左下の遠く\n        vec2 center3 = vec2(2.0, -4.5);  // 右下の遠く\n        vec2 center4 = vec2(-3.0, 3.8);  // 左上の遠く\n\n        // それぞれの中心からの距離\n        float dist1 = length(p - center1);\n        float dist2 = length(p - center2);\n        float dist3 = length(p - center3);\n        float dist4 = length(p - center4);\n\n        // フローフィールドで歪ませる（時間でゆらめく）\n        float flowT1 = sin(t * u_speed * 0.15) * 2.0;\n        float flowT2 = cos(t * u_speed * 0.12) * 2.0;\n        vec2 flowDir = vec2(fbm(p * 1.2 + flowT1), fbm(p * 1.2 + flowT2));\n        vec2 distortedP = p + flowDir * 0.4;\n\n        // 動的に波を生成\n        int numWaves = int(u_waveCount);\n        float combined = 0.0;\n        float totalWeight = 0.0;\n\n        // 歪んだ位置も計算\n        float dist1d = length(distortedP - center1);\n        float dist2d = length(distortedP - center2);\n\n        // 波のパラメータ配列（最大8波）\n        for(int i = 0; i < 8; i++) {\n          if(i >= numWaves) break;\n\n          float fi = float(i);\n          float dist = i == 0 ? dist1 :\n                       i == 1 ? dist2 :\n                       i == 2 ? dist3 :\n                       i == 3 ? dist4 :\n                       i == 4 ? dist1d :\n                       i == 5 ? dist2d :\n                       i == 6 ? dist3 : dist4;\n\n          // 基本周波数と位相（位置は固定）\n          float baseFreq = 4.0 + fi * 0.4;\n          float phase = fi * 0.785;\n\n          // 時間でゆらめく振幅と周波数\n          float freqModulation = sin(t * u_speed * (0.3 + fi * 0.05)) * 0.3;\n          float amplitudeModulation = sin(t * u_speed * (0.2 + fi * 0.04) + phase) * 0.5 + 0.5;\n\n          // 周波数が時間とともに変化（ゆらめき）\n          float dynamicFreq = baseFreq * (1.0 + freqModulation);\n\n          // 波形（ゆるやかにゆらめく）\n          float wave = sin(dist * dynamicFreq + phase) * 0.5 + 0.5;\n\n          // 振幅も時間で変化\n          wave = wave * (0.7 + amplitudeModulation * 0.3);\n\n          float weight = 0.25 / (1.0 + fi * 0.15);\n\n          combined += wave * weight;\n          totalWeight += weight;\n        }\n\n        // FBMでさらに複雑に（ゆらめく）\n        float fbmT = sin(t * u_speed * 0.1) * 1.5;\n        float fbmPattern = fbm(p * 2.5 + fbmT);\n        combined = (combined / totalWeight) * 0.85 + fbmPattern * 0.15;\n\n        // 明るさベースのブレンディング\n        float brightness = smoothstep(0.3, 0.7, combined);\n\n        // 暗い夜空から始まる青のグラデーション\n        vec3 col = mix(u_c0, u_c1, brightness);\n        col = mix(col, u_c2, smoothstep(0.5, 0.8, combined));\n\n        // 波の干渉パターンで光を追加（ゆらめく）\n        float glow = 0.0;\n        if(numWaves >= 2) {\n          // 周波数がゆらめく\n          float freq1 = 4.0 * (1.0 + sin(t * u_speed * 0.3) * 0.3);\n          float freq2 = 4.8 * (1.0 + sin(t * u_speed * 0.25) * 0.3);\n          float w1 = sin(dist1 * freq1) * 0.5 + 0.5;\n          float w2 = sin(dist2 * freq2 + 1.57) * 0.5 + 0.5;\n          glow += pow(w1 * w2, 1.8) * 0.25;\n        }\n        if(numWaves >= 4) {\n          float freq3 = 4.4 * (1.0 + sin(t * u_speed * 0.28) * 0.3);\n          float freq5 = 5.2 * (1.0 + sin(t * u_speed * 0.22) * 0.3);\n          float w3 = sin(dist3 * freq3) * 0.5 + 0.5;\n          float w5 = sin(dist1d * freq5) * 0.5 + 0.5;\n          glow += pow(w3 * w5, 2.0) * 0.2;\n        }\n        if(numWaves >= 6) {\n          float freq4 = 4.6 * (1.0 + sin(t * u_speed * 0.26) * 0.3);\n          float freq6 = 5.0 * (1.0 + sin(t * u_speed * 0.24) * 0.3);\n          float w4 = sin(dist4 * freq4 + 3.14) * 0.5 + 0.5;\n          float w6 = sin(dist2d * freq6) * 0.5 + 0.5;\n          glow += pow(w4 * w6, 2.2) * 0.15;\n        }\n\n        // オーロラのような光を加算\n        col += u_c2 * glow * 1.2;\n        col += u_c1 * pow(glow + 0.01, 2.0) * 0.6;\n\n        // 波の重なりで明るいハイライト\n        if(numWaves >= 5) {\n          float freq1 = 4.0 * (1.0 + sin(t * u_speed * 0.3) * 0.3);\n          float freq5 = 5.2 * (1.0 + sin(t * u_speed * 0.22) * 0.3);\n          float w1 = sin(dist1 * freq1) * 0.5 + 0.5;\n          float w5 = sin(dist1d * freq5) * 0.5 + 0.5;\n          float highlight = pow(w1 * w5, 2.5) * 0.4;\n          col += u_c2 * highlight;\n        }\n\n        // 複数の波が重なる場所に輝きを追加\n        if(numWaves >= 3) {\n          float freq1 = 4.0 * (1.0 + sin(t * u_speed * 0.3) * 0.3);\n          float freq2 = 4.8 * (1.0 + sin(t * u_speed * 0.25) * 0.3);\n          float freq3 = 4.4 * (1.0 + sin(t * u_speed * 0.28) * 0.3);\n          float w1 = sin(dist1 * freq1) * 0.5 + 0.5;\n          float w2 = sin(dist2 * freq2 + 1.57) * 0.5 + 0.5;\n          float w3 = sin(dist3 * freq3) * 0.5 + 0.5;\n          float multiWave = w1 * w2 * w3;\n          col += vec3(u_c2 * 0.5) * pow(multiWave, 2.0);\n        }\n\n        // デバッグモード: 波の外形だけを表示\n        if(u_debugMode > 0.5) {\n          // 各波のエッジを検出\n          float edges = 0.0;\n          for(int i = 0; i < 8; i++) {\n            if(i >= numWaves) break;\n            float fi = float(i);\n            float dist = i == 0 ? dist1 :\n                         i == 1 ? dist2 :\n                         i == 2 ? dist3 :\n                         i == 3 ? dist4 :\n                         i == 4 ? dist1d :\n                         i == 5 ? dist2d :\n                         i == 6 ? dist3 : dist4;\n\n            float baseFreq = 4.0 + fi * 0.4;\n            float phase = fi * 0.785;\n            float freqModulation = sin(t * u_speed * (0.3 + fi * 0.05)) * 0.3;\n            float dynamicFreq = baseFreq * (1.0 + freqModulation);\n\n            // 波形\n            float wave = sin(dist * dynamicFreq + phase) * 0.5 + 0.5;\n\n            // エッジを検出（波が極値に近い場所）\n            float edge = 1.0 - smoothstep(0.0, 0.08, abs(wave - 0.5));\n            edges += edge;\n          }\n\n          // 白い線で波の外形を表示\n          col = vec3(edges * 1.5);\n        } else {\n          // 通常モード: グラデーション表示\n          col = col * u_intensity;\n\n          // 距離による自然な減衰（控えめ）\n          float localDist = min(min(dist1, dist2), min(dist3, dist4));\n          float falloff = 1.0 - smoothstep(2.0, 6.0, localDist);\n          col *= 0.55 + 0.45 * falloff;\n        }\n\n        gl_FragColor = vec4(col, 1.0);\n      }`;\n\n    const mat = new THREE.ShaderMaterial({\n      vertexShader: `void main(){ gl_Position = vec4(position,1.0); }`,\n      fragmentShader: frag,\n      uniforms,\n      transparent: true\n    });\n\n    const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);\n    scene.add(quad);\n\n    const ro = new ResizeObserver(() => {\n      if (!rendererRef.current || !wrapRef.current) return;\n      const w = wrapRef.current.clientWidth, h = wrapRef.current.clientHeight;\n      rendererRef.current.setSize(w, h);\n      (uniforms.u_res.value as THREE.Vector2).set(w, h);\n    });\n    ro.observe(el);\n\n    let raf = 0;\n    const loop = (now: number) => {\n      uniforms.u_time.value = now * 0.001;\n      renderer.render(scene, camera);\n      raf = requestAnimationFrame(loop);\n    };\n    raf = requestAnimationFrame(loop);\n\n    return () => {\n      cancelAnimationFrame(raf);\n      ro.disconnect();\n      renderer.dispose();\n      el.removeChild(renderer.domElement);\n    };\n  }, [colors.join(\",\"), speed, intensity, waveCount, debugMode]);\n\n  return <div ref={wrapRef} className={className} style={{position:\"absolute\", inset:0}} aria-hidden />;\n}\n"],"mappings":"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","names":[]}